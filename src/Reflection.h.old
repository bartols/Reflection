#pragma once

#ifndef _REFLECTION_H_
#define _REFLECTION_H_

// todo REFLECT_ENUM_BEGIN
// todo UTF8

#include <vector>
#include <string>
#include <stdarg.h>
#include "optional.hpp"

//#define CPP98

#ifdef CPP98
#include <stddef.h>
// null ptr
#define nullptr 0
// override
#define override
#endif

namespace reflect {

	struct TypeDescriptor;

	enum eFieldType {
		attribute,
		element,
		direct
	};
	
	class Visitor
	{
	public:
		virtual ~Visitor() {}
		virtual bool visit_struct_start( const char* field_name, TypeDescriptor* tdescr ) = 0;
		virtual bool visit_struct_end( const char* field_name, TypeDescriptor* tdescr ) = 0;
		virtual bool visit_vector_start( const char* field_name, void* field, TypeDescriptor* tdescr, eFieldType type ) = 0;
		virtual bool visit_vector_end( const char* field_name, void* field, TypeDescriptor* tdescr, eFieldType type ) = 0;
		virtual bool check_optional_field( const char* field_name, void* field, TypeDescriptor* tdescr, eFieldType type ) = 0;
		virtual bool visit_field( const char* field_name, void* obj, TypeDescriptor* tdescr, eFieldType type ) = 0;

		void set_error_msg( const char* format, ... );
		const std::string& get_error_msg() const		{ return _last_error_msg; }
	private:
		std::string _last_error_msg;
	};

	//--------------------------------------------------------
	// Base class of all type descriptors
	//--------------------------------------------------------
	struct TypeDescriptor
	{
		enum eNodeType {
			node_struct,
			node_vector,
			node_optional,
			node_field
		};

		const char* name;
		size_t size;
		eNodeType node_type;

		TypeDescriptor( const char* name, size_t size, eNodeType type )
			: name( name ), size( size ), node_type( type ) {}

		virtual ~TypeDescriptor() {}

		virtual std::string getFullName() const { return name; }

		// accept visitor
		virtual bool accept( Visitor& v, void* obj, const char* field_name = nullptr, eFieldType type = element )
		{
			return v.visit_field( field_name, obj, this, type );
		}

		// to string
		virtual std::string to_string( const void* field ) const = 0;
		// from string
		virtual bool from_string( const std::string& str, const void* field ) = 0;
	};

	//--------------------------------------------------------
	// Finding type descriptors
	//--------------------------------------------------------

	// Declare the function template that handles primitive types such as int, std::string, etc.:
	template <typename T>
	TypeDescriptor* getPrimitiveDescriptor();

	// This is the primary class template for finding all TypeDescriptors:
	template <typename T>
	struct TypeResolver {
		static TypeDescriptor* get() {
			return getPrimitiveDescriptor<T>();
		}
	};

	//--------------------------------------------------------
	// Type descriptors for user-defined structs/classes
	//--------------------------------------------------------
	struct TypeDescriptor_Struct : TypeDescriptor 
	{
		// struct member
		struct Member {
			const char* field_name;
			size_t offset;
			TypeDescriptor* type;
			eFieldType field_type;
		};

		std::vector<Member> members;

		TypeDescriptor_Struct()
			: TypeDescriptor( nullptr, 0, node_struct )
		{
		}

		void initialize( void (*init)(TypeDescriptor_Struct*) )
		{
			init( this );
		}

		// accept visitor
		bool accept( Visitor& v, void* obj, const char* field_name, eFieldType type ) override
		{
			if( !v.visit_struct_start( field_name, this ) )
				return false;

			char* curr = reinterpret_cast<char*>(obj);
			std::vector<Member>::const_iterator it_end = members.end();
			for( std::vector<Member>::const_iterator it = members.begin(); it != it_end; ++it )
			{
				const Member& member = (*it);
				if( !member.type->accept( v, curr + member.offset, member.field_name, member.field_type ) )
					return false;
			}

			return v.visit_struct_end( field_name, this );
		}

		// to string for struct return the name
		std::string to_string( const void* field ) const override
		{
			return getFullName();
		}

		// from string
		bool from_string( const std::string& str, const void* field ) override
		{
			// only for pod value
			return true;
		}
	};

	// generic init reflection
	template<typename T>
	void initReflection( TypeDescriptor_Struct* );

#define __REFLECT_BEGIN(type, as_name) \
	namespace reflect { \
	template<typename T> \
	TypeDescriptor* selectResolver( T type::* ) { \
		return TypeResolver<T>::get(); \
	} \
	template<> void initReflection<type>( TypeDescriptor_Struct* typeDesc ); \
	template<> TypeDescriptor* getPrimitiveDescriptor<type>() \
	{ \
		static TypeDescriptor_Struct typeDesc; \
		static bool initialized = false; \
		if( !initialized ) \
		{ \
			initialized = true; \
			typeDesc.initialize( initReflection<type> ); \
		} \
		return &typeDesc; \
	} \
	template<> \
    void initReflection<type>(TypeDescriptor_Struct* typeDesc) { \
        typedef type T; \
        typeDesc->name = #as_name; \
        typeDesc->size = sizeof(type);

#define __REFLECT_MEMBER( field, name, fld_type ) \
		{ \
			TypeDescriptor_Struct::Member memb; \
			memb.field_name = #name; \
			memb.offset = offsetof( T, field ); \
			memb.type = selectResolver(&T::field); \
			memb.field_type = fld_type; \
			typeDesc->members.push_back( memb ); \
		}
#define	REFLECT_BEGIN(type)						__REFLECT_BEGIN( type, type )
#define	REFLECT_BEGIN_AS(type, name)			__REFLECT_BEGIN( type, name )

#define REFLECT_MEMBER_ELEM( type )				__REFLECT_MEMBER( type, field, element )
#define REFLECT_MEMBER_ELEM_AS( type, name )	__REFLECT_MEMBER( type, name, element )

#define REFLECT_MEMBER_ATTR( type )				__REFLECT_MEMBER( type, field, attribute )
#define REFLECT_MEMBER_ATTR_AS( type, name )	__REFLECT_MEMBER( type, name, attribute )

#define REFLECT_MEMBER_UNAMED(type)				__REFLECT_MEMBER( type, type, direct )
#define REFLECT_MEMBER_UNAMED_AS(type, name)	__REFLECT_MEMBER( type, name, direct )

#define REFLECT_END() \
		} \
    }

	//--------------------------------------------------------
	// Type descriptors for std::vector
	//--------------------------------------------------------
	struct TypeDescriptor_StdVector : TypeDescriptor
	{
		template <typename ItemType>
		TypeDescriptor_StdVector( ItemType* )
			: TypeDescriptor( "std::vector<>", sizeof( std::vector<ItemType> ), node_vector ),
			itemType( TypeResolver<ItemType>::get() )
		{
			resize = &resizeTemplated<ItemType>;
			count = &countTemplated<ItemType>;
			at = &atTemplated<ItemType>;
			append = &appendTemplated<ItemType>;
		}

		virtual std::string getFullName() const override
		{
			return std::string( "std::vector<" ) + itemType->getFullName() + ">";
		}

		// accept visitor
		bool accept( Visitor& v, void* obj, const char* field_name, eFieldType type ) override
		{
			if( !v.visit_vector_start( field_name, obj, this, type ) )
				return false;

			const char* name = (itemType->node_type == node_struct) ? itemType->name : "";

			size_t numItems = count( itemType, obj );
			for( size_t index = 0; index < numItems; ++index )
			{
				if( !itemType->accept( v, at( itemType, obj, index ), name ) )
					return false;
			}

			return v.visit_vector_end( field_name, obj, this, type );
		}

		// to string for struct return the name
		std::string to_string( const void* field ) const override
		{
			return getFullName();
		}

		// from string
		bool from_string( const std::string& str, const void* field ) override
		{
			// only for pod value
			return false;
		}

		// vector method
		void (*resize)(const TypeDescriptor* type, void*, size_t);
		size_t( *count )(const TypeDescriptor* type, const void*);
		void* (*at)(const TypeDescriptor* type, const void*, size_t);
		void(*append)(const TypeDescriptor* type, void*);

		TypeDescriptor* itemType;

	private:
		// assign function pointer

		// resize
		template<typename ItemType>
		static void resizeTemplated( const TypeDescriptor* type, void* vecptr, size_t size )
		{
			(*reinterpret_cast<std::vector<ItemType>*>(vecptr)).resize( size );
		}

		// count
		template<typename ItemType>
		static size_t countTemplated( const TypeDescriptor* type, const void* vecptr )
		{
			return (*reinterpret_cast<const std::vector<ItemType>*>(vecptr)).size();
		}

		// at
		template<typename ItemType>
		static void * atTemplated( const TypeDescriptor* type, const void* vecptr, size_t pos )
		{
			return &((*(std::vector<ItemType>*)vecptr).at( pos ));
		}

		// append
		template<typename ItemType>
		static void appendTemplated( const TypeDescriptor* type, void* vecptr )
		{
			(*reinterpret_cast<std::vector<ItemType>*>(vecptr)).push_back( ItemType() );
		}
	};

	// Partially specialize TypeResolver<> for std::vectors:
	template <typename T>
	class TypeResolver< std::vector<T> > {
	public:
		static TypeDescriptor* get() {
			static TypeDescriptor_StdVector typeDesc( (T*) nullptr );
			return &typeDesc;
		}
	};

	//--------------------------------------------------------
	// Type descriptors for nonstd::optional
	//--------------------------------------------------------
	struct TypeDescriptor_StdOptional : TypeDescriptor
	{
		template <typename ItemType>
		TypeDescriptor_StdOptional( ItemType* )
			: TypeDescriptor( "std::optional<>", sizeof( nonstd::optional<ItemType> ), node_optional ),
			itemType( TypeResolver<ItemType>::get() )
		{
			has_value = &hasvalueTemplated<ItemType>;
			value = &valueTemplated<ItemType>;
			set_value= &setvalueTemplated<ItemType>;
		}

		virtual std::string getFullName() const override
		{
			return std::string( "std::optional<" ) + itemType->getFullName() + ">";
		}

		// accept visitor
		bool accept( Visitor& v, void* obj, const char* field_name, eFieldType type ) override
		{
			if( v.check_optional_field( field_name, obj, this, type ) )
			{
				try {
					return itemType->accept( v, value( itemType, obj ), field_name, type );
				}
				catch( const nonstd::bad_optional_access & e )
				{
					v.set_error_msg( "Exception: %s", e.what() );
					return false;
				}
			}
			return true;
		}

		// to string use underlying type
		std::string to_string( const void* field ) const override
		{
			return itemType->to_string( field );
		}

		// from string
		bool from_string( const std::string& str, const void* field ) override
		{
			// only for pod value
			return false;
		}

		TypeDescriptor* itemType;

		// optional method
		bool (*has_value)(const TypeDescriptor* type, const void*);
		void*(*value)(const TypeDescriptor* type, void*);
		void(*set_value)(const TypeDescriptor* type, void*);
	private:
		// assign function pointer

		// has value
		template<typename ItemType>
		static bool hasvalueTemplated( const TypeDescriptor* type, const void* optptr )
		{
			return (*reinterpret_cast<const nonstd::optional<ItemType>*>(optptr)).has_value();
		}

		// value
		template<typename ItemType>
		static void * valueTemplated( const TypeDescriptor* type, void* optptr )
		{
			return &((*(nonstd::optional<ItemType>*)optptr).value());
		}

		// set value
		template<typename ItemType>
		static void setvalueTemplated( const TypeDescriptor* type, void* optptr )
		{
			(*(nonstd::optional<ItemType>*)optptr).operator=( ItemType() );
		}
	};

	// Partially specialize TypeResolver<> for std::optional:
	template <typename T>
	class TypeResolver< nonstd::optional<T> > {
	public:
		static TypeDescriptor* get() {
			static TypeDescriptor_StdOptional typeDesc( (T*) nullptr );
			return &typeDesc;
		}
	};
} // namespace reflect

#endif // _REFLECTION_H_
